#!/usr/bin/env node

// Script to export database schema to a reference file
// Usage: npm run schema:update
import { createClient } from '@supabase/supabase-js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing Supabase environment variables');
  console.error('Make sure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

async function exportSchema() {
  const schemaData = {
    timestamp: new Date().toISOString(),
    tables: {},
    relationships: [],
    functions: []
  };

  const tables = ['tournaments', 'contestants', 'rounds', 'matchups', 'votes', 'users'];

  console.log('Exporting database schema...');

  // Get table schemas
  for (const table of tables) {
    try {
      const { data, error } = await supabase
        .from('information_schema.columns')
        .select('column_name, data_type, is_nullable, column_default, character_maximum_length')
        .eq('table_name', table)
        .eq('table_schema', 'public')
        .order('ordinal_position');

      if (error) throw error;

      schemaData.tables[table] = data;
      console.log(`✓ Exported ${table} schema`);
    } catch (err) {
      console.error(`✗ Failed to export ${table}:`, err.message);
    }
  }

  // Get foreign key relationships
  try {
    const { data, error } = await supabase.rpc('get_foreign_keys', {
      schema_name: 'public',
      table_names: tables
    });

    if (!error && data) {
      schemaData.relationships = data;
      console.log('✓ Exported foreign key relationships');
    }
  } catch (err) {
    console.log('⚠ Could not export relationships (function may not exist)');
  }

  // Get tournament-related functions
  try {
    const { data, error } = await supabase
      .from('information_schema.routines')
      .select('routine_name, routine_type, data_type')
      .eq('routine_schema', 'public')
      .or('routine_name.like.%tournament%,routine_name.like.%bracket%,routine_name.like.%matchup%,routine_name.like.%round%');

    if (!error && data) {
      schemaData.functions = data;
      console.log('✓ Exported tournament functions');
    }
  } catch (err) {
    console.log('⚠ Could not export functions');
  }

  // Write to file
  const outputPath = path.join(__dirname, '..', 'SCHEMA_REFERENCE.md');
  let content = `# Database Schema Reference

> **⚠️ AUTO-GENERATED FILE**  
> This file is automatically generated. Do not edit manually.  
> To update: run \`npm run schema:update\`

Generated on: ${schemaData.timestamp}

This file contains the exact database schema to prevent column name mismatches when writing SQL code.

## Tables

`;

  // Format table schemas
  for (const [tableName, columns] of Object.entries(schemaData.tables)) {
    content += `### ${tableName}\n\n`;
    content += '| Column | Type | Nullable | Default | Max Length |\n';
    content += '|--------|------|----------|---------|------------|\n';
    
    for (const col of columns) {
      content += `| ${col.column_name} | ${col.data_type} | ${col.is_nullable} | ${col.column_default || 'NULL'} | ${col.character_maximum_length || 'N/A'} |\n`;
    }
    content += '\n';
  }

  // Add relationships if available
  if (schemaData.relationships.length > 0) {
    content += '## Foreign Key Relationships\n\n';
    content += '| Table | Column | References Table | References Column |\n';
    content += '|-------|--------|------------------|------------------|\n';
    
    for (const rel of schemaData.relationships) {
      content += `| ${rel.table_name} | ${rel.column_name} | ${rel.foreign_table_name} | ${rel.foreign_column_name} |\n`;
    }
    content += '\n';
  }

  // Add functions if available
  if (schemaData.functions.length > 0) {
    content += '## Tournament-Related Functions\n\n';
    content += '| Function Name | Type | Return Type |\n';
    content += '|---------------|------|-------------|\n';
    
    for (const func of schemaData.functions) {
      content += `| ${func.routine_name} | ${func.routine_type} | ${func.data_type} |\n`;
    }
    content += '\n';
  }

  content += `## Common Mistakes to Avoid

1. **Column Names**: Always use exact column names from the tables above
2. **Foreign Keys**: Use the relationships table to verify correct column references
3. **Data Types**: Match the exact data types when creating functions
4. **Null Constraints**: Check nullable column before assuming values exist

## Quick Reference

### Most Common Columns:
- **tournaments**: id, name, description, status, max_contestants, created_by, created_at, updated_at
- **contestants**: id, tournament_id, name, description, image_url, seed, created_at
- **rounds**: id, tournament_id, name, round_number, status, created_at
- **matchups**: id, round_id, match_number, contestant1_id, contestant2_id, winner_id, status, contestant1_votes, contestant2_votes, total_votes
- **votes**: id, matchup_id, user_id, selected_contestant_id, created_at
- **users**: id, email, is_admin, created_at, updated_at

### Key Relationships:
- contestants.tournament_id → tournaments.id
- rounds.tournament_id → tournaments.id
- matchups.round_id → rounds.id
- matchups.contestant1_id → contestants.id
- matchups.contestant2_id → contestants.id
- votes.matchup_id → matchups.id
- votes.user_id → users.id
`;

  fs.writeFileSync(outputPath, content);
  console.log(`✓ Schema reference saved to: ${outputPath}`);
}

exportSchema().catch(console.error);